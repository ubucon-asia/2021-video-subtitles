1
00:00:13,600 --> 00:00:14,700
大家好。

2
00:00:15,034 --> 00:00:22,700
在這部影片中，我的題目是信號追蹤(signal tracing)。

3
00:00:23,677 --> 00:00:30,611
我的名字是Leesoo Ahn，現於一間無線路由器公司擔任工程師。

4
00:00:31,034 --> 00:00:40,900
我自2018年起便擔任GNONE的貢獻者，目前正在做與內核(kernal)相關的研究。

5
00:00:42,100 --> 00:00:45,800
我相信你們之中有些人已經對信號有所了解。

6
00:00:46,700 --> 00:00:52,500
信號是在Linux系統之中，眾多形程間通訊(inter-process communication)之一。

7
00:00:52,500 --> 00:01:00,500
舉例來說，這裡有兩個行程：父行程與子行程。

8
00:01:00,500 --> 00:01:08,600
父行程正在傳送一個訊息給子行程，整體的情況是IPC.

9
00:01:10,100 --> 00:01:14,200
訊息便是信號的一種。

10
00:01:16,600 --> 00:01:20,300
當然，子行程也可以對父行程做出回應。

11
00:01:21,200 --> 00:01:26,100
取決於子行程是如何被實現(implemented)的。

12
00:01:28,700 --> 00:01:33,700
這樣的情況常見於教科書中。

13
00:01:34,700 --> 00:01:36,700
乍看之下並無問題，但是...

14
00:01:38,000 --> 00:01:43,700
在現實世界中有比這些範例更加複雜的狀況。

15
00:01:47,100 --> 00:01:53,400
比方說，有可能數個完全無相關的行程向各自的子行程傳送信號。

16
00:01:53,400 --> 00:01:57,600
也有可能父行程沒有收到應得的信號。

17
00:02:00,300 --> 00:02:07,067
當我們碰到信號相關的問題，如果不知道如何分析信號，將會非常難以解決。

18
00:02:07,900 --> 00:02:11,600
我們可以怎麼做？

19
00:02:13,100 --> 00:02:17,500
有一些工具適合用於此類分析此類問題。

20
00:02:19,100 --> 00:02:27,034
第一個工具是GDB，GDB是一個逐行除錯器(debugger)。

21
00:02:27,267 --> 00:02:34,800
你可以將它連接於一個行程，然後你可以逐行檢查實時的運行資訊。

22
00:02:38,367 --> 00:02:44,867
第二，我們也可以使用Strace，它比GDB更加的輕量化。

23
00:02:45,534 --> 00:02:51,100
而且它被設計成專心於追蹤系統呼叫(System-calls)與信號。

24
00:02:52,900 --> 00:03:09,600
第三，我們有Ftrace，有別於GDB及Strace，Ftrace可以追蹤整個系統(system-wide)及分析幾乎所有內核中的事件。

25
00:03:12,000 --> 00:03:16,000
一定有其它的，我所不知的技巧。

26
00:03:16,900 --> 00:03:18,734
但是假如...

27
00:03:19,800 --> 00:03:22,000
前述的情況發生了。

28
00:03:23,100 --> 00:03:27,800
當系統正在啟動(booting up)之時，有更多事情需要考慮。

29
00:03:31,800 --> 00:03:45,400
像是GDB、Strace及Ftrace的工具是存放於檔案系統， 但是假如在檔案系統掛載時出現了錯誤，我們便不能使用這些工具。

30
00:03:47,600 --> 00:03:52,500
加上，也需要考慮目標行程及除錯器的執行順序。

31
00:03:53,500 --> 00:04:02,200
舉例說，如果我們在目標行程執行前便執行除錯器，分析便是無效的。

32
00:04:04,300 --> 00:04:17,200
更進一步，在嵌入式系統中，Shell基於安全因素將會被關閉，因此在這樣的環境中我們將無法透過電腦終端(terminal)執行除錯器。

33
00:04:19,600 --> 00:04:23,800
除了上述之外，還需要考慮更多事情。

34
00:04:24,500 --> 00:04:32,800
我們知道這不是問題的核心，單是它迫使我們專注於如此煩人的作業，因此它是極度惱人且有壓力的。

35
00:04:34,800 --> 00:04:41,634
比起那樣，專注於原本的問題而且迅速的將它完成才是比較理想的，對吧？

36
00:04:44,700 --> 00:04:56,134
既然修改程式碼去解決問題是正確的作法，那存取及分析內核中的信號處理路線將會是很有效率的做法，對吧？

37
00:04:58,200 --> 00:05:00,800
我將以這樣的思考處理這個問題。

38
00:05:03,200 --> 00:05:14,400
復述一次，現在這裡有兩個行程，父行程正在傳送一個訊息給子行程。這是訊號處理(signal processing)的示意圖。

39
00:05:16,200 --> 00:05:18,400
而這是現實中內核的顯示內容。

40
00:05:18,400 --> 00:05:28,367
父行程以"kill"系統呼叫，向內核請求一個信號。內核處理這個信號，並將它傳送給子行程。

41
00:05:30,000 --> 00:05:37,700
將內核等級再次分割，可以分成三個階段。

42
00:05:38,200 --> 00:05:42,900
在這三個階段中，我們將編輯第三階段的程式碼。

43
00:05:44,900 --> 00:05:55,800
你可能會想，總共有三個階段，為甚麼我們要編輯第三階段的程式碼？背後的原因便是安全性。

44
00:05:56,800 --> 00:06:04,500
內核必須在處理所有由使用者傳送的數值之時，都必須進行例外處理。

45
00:06:04,500 --> 00:06:15,000
舉例來說，使用者可能傳送一個不合規範的信號碼(signal number)，這樣的情況一定需要被檢查。

46
00:06:16,800 --> 00:06:20,900
第二，我們應該檢查行程，意思是確保...

47
00:06:20,900 --> 00:06:25,600
目標行程在系統內是存活(alive)的。

48
00:06:25,600 --> 00:06:30,500
如果目標行程並不存在，就不需要處理這個訊號。

49
00:06:32,300 --> 00:06:39,200
再加上，如果在一個行程中有多個執行緒，你需要檢查應該把訊號傳送至哪個執行緒。

50
00:06:43,200 --> 00:06:46,800
之後，你需要檢查在程式碼層級檢查空指標。

51
00:06:47,034 --> 00:06:53,400
以及許多其他事情，例如安全性考量。

52
00:06:56,700 --> 00:07:02,000
現在我們了解為何應該編輯第三階段的程式碼，那我們該如何實行？

53
00:07:03,000 --> 00:07:09,900
簡短而言。第一，我們應該篩選掉所有不必要的訊號。

54
00:07:12,000 --> 00:07:15,900
使用指令"printk"，我們將把結果輸出到主控台(console)。

55
00:07:18,200 --> 00:07:27,400
在內容中，傳送者及接收者的行程名稱及PID，加上信號碼都會被輸出。

56
00:07:28,200 --> 00:07:33,500
這是我做得的一個簡單的補丁，基於剛剛我們需要的資訊。

57
00:07:33,500 --> 00:07:42,700
我使它篩選出SIGCHLD及SIGALRM，加上輸出傳送者、接收者及信號碼。

58
00:07:44,700 --> 00:07:49,500
這是在"kill"系統呼叫執行時，內核的呼叫堆積(call stack)。

59
00:07:49,500 --> 00:08:01,600
在結束了階段一及階段二的處理之後，在send_signal函式內，在complete_signal完成之後將會輸出。

60
00:08:02,600 --> 00:08:09,700
在此之後，我將會簡短的操作一個套用了前述補丁的系統。

61
00:08:18,000 --> 00:08:21,400
這個終端目前連接於樹梅派(Raspberry Pi)。

62
00:08:22,700 --> 00:08:24,800
目前正在重新啟動。

63
00:08:26,000 --> 00:08:28,200
我們將在啟動完畢之後繼續解說。

64
00:08:40,900 --> 00:08:47,600
現在啟動已經完成，我們來慢慢分析啟動訊息(boot message)。

65
00:08:54,300 --> 00:09:00,200
我們可以看到，在檔案系統初始化以前。

66
00:09:01,400 --> 00:09:10,000
此時信號如前述，可以被傳輸，但是很難用前面提到的工具追蹤。

67
00:09:10,900 --> 00:09:17,900
如果你分析內核，你可以像這樣很簡單的檢查它。

68
00:09:19,200 --> 00:09:28,100
再重複一次，這是檔案系統初始化的資訊，而且在他完成之前將會送出一個訊號。

69
00:09:29,100 --> 00:09:37,800
我們將會在Shell裡通過"kill"指令送出一個信號。

70
00:09:38,800 --> 00:09:46,800
我將使用"kill"指令傳送一個信號給DHCP client。

71
00:09:47,500 --> 00:09:51,500
現在我要使用這條指令來傳送信號。

72
00:09:53,700 --> 00:10:04,700
接下來，如你所見在內核訊息中，傳送者為Shell，接收者則為Shell中的DHCP client。

73
00:10:05,000 --> 00:10:13,200
你可以透過訊息確認SIGUSR1的訊號已經傳送。

74
00:10:16,100 --> 00:10:26,634
接下來，我將向你展示在"reboot"(重新啟動)指令下信號如何運作。

75
00:10:27,634 --> 00:10:31,500
我運行"reboot"指令。

76
00:10:31,867 --> 00:10:32,600
我將在...

77
00:10:33,700 --> 00:10:38,200
重新啟動完成之後再做說明。

78
00:10:54,800 --> 00:10:58,400
重新啟動幾乎要完成了。

79
00:10:59,300 --> 00:11:06,700
我將解釋"reboot"指令所生成的信號內容。

80
00:11:07,400 --> 00:11:17,367
首先，當"reboot"指令執行時，將會發送一個信號給所有運行中的行程。

81
00:11:20,000 --> 00:11:24,534
當數值等於15之時，便是SIGTERM的信號碼。

82
00:11:25,100 --> 00:11:32,100
以這樣的方法，當所有行程都被終結之後，重新啟動便會被順利地執行。

83
00:11:33,700 --> 00:11:46,400
因此，在重新啟動的過程中，是有可能透過內核修改達到分析訊號的目的。

84
00:11:50,200 --> 00:11:59,167
現在讓我們結束演示並回到報告。

85
00:12:03,900 --> 00:12:15,867
在這次的報告中，與其對內核有非常深入的了解，我自因問題發生而修改內核的角度解釋。

86
00:12:15,900 --> 00:12:20,800
我很高興你對於內核有更深的了解。

87
00:12:21,667 --> 00:12:24,600
我也在將在這裡結束我的報告。

88
00:12:24,867 --> 00:12:26,034
謝謝大家。

