1
00:00:13,600 --> 00:00:14,700
안녕하세요.

2
00:00:15,034 --> 00:00:22,700
이번 세션에서는 커널 해킹하여 시그널을 추적하는 것에 대해 이야기하겠습니다.

3
00:00:23,677 --> 00:00:30,611
제 이름은 안이수라고 하고요 현재 무선공유기 회사에서 엔지니어로 일하고 있습니다. 

4
00:00:31,034 --> 00:00:40,900
2018년부터 2년간 GNONE에서 컨트리뷰터로 활동했고 현제는 커널과 관련된 연구를 진행하고 있습니다.

5
00:00:42,100 --> 00:00:45,800
 아마 여기 계신 분들은 이미 시그널에 대해 알고 계실 거예요.

6
00:00:46,700 --> 00:00:52,500
시그널은 현재 리눅스에 존재하는 많은 Inter-process communication 중의 하나 인데요

7
00:00:52,500 --> 00:01:00,500
간단한 예제를 보여드리자면 여기 부모와 자식 두 개 프로세스가 있습니다.

8
00:01:00,500 --> 00:01:08,600
부모가 자식에게 메시지를 전달하고 있는데 이 전체적인 그림이 IPC이고요.

9
00:01:10,100 --> 00:01:14,200
 그리고 거기에 사용되는 메시지가 바로 Signal입니다.

10
00:01:16,600 --> 00:01:20,300
물론 자식도 부모에게 응답할 수 있지만.

11
00:01:21,200 --> 00:01:26,100
그건 오로지 자식 프로그램이 어떻게 구현되어 있는가에 따라 달라져요.

12
00:01:28,700 --> 00:01:33,700
앞 예시에 나온 상황은 흔히 우리가 텍스트북에서 보던 내용이죠.

13
00:01:34,700 --> 00:01:36,700
문제도 없고 괜찮아 보이지만

14
00:01:38,000 --> 00:01:43,700
프로덕트에서는 이렇게 행복한 상황보다는 복잡한 상황이 더 많이 발생해요.

15
00:01:47,100 --> 00:01:53,400
예를 들면 전혀 상관없는 프로세스들이 자식에게 시그널을 보내는 경우도 있고,

16
00:01:53,400 --> 00:01:57,600
 부모가 보낸 시그널을 받지 못하는 상황도 생길 수 있어요.

17
00:02:00,300 --> 00:02:06,900
시그널과 관련된 문제가 생겼을 때에 분석하는 방법을 알면 손쉽게 해결할 수 있는데

18
00:02:07,900 --> 00:02:11,600
 도대체 어떻게 해야 할까요?

19
00:02:13,100 --> 00:02:17,500
몇 가지 툴을 이용해서 이러한 문제점들을 분석할 수 있어요.

20
00:02:19,100 --> 00:02:27,034
첫 번째는 여러분들이 아는 툴인데요 GDB는 line-by-lline 디버거이고

21
00:02:27,267 --> 00:02:33,800
 프로세스에 Attach하면 현재 실행 중인 부분을 line-by-line으로 확인할 수 있어요.

22
00:02:38,367 --> 00:02:44,867
그 다음은 Strace 인데 Strace 같은 경우에는 GDB 보다 경량화 되어 있고

23
00:02:45,534 --> 00:02:51,100
 System-call과 시그널만 트레이싱 할 수 있도록 설계 되었어요.

24
00:02:52,900 --> 00:03:09,600
세 번째는 Ftrace라고 하는 툴인데요 Ftrace는 GDB와 Strace와는 다르게 시스템 전역적으로 트레이스가 가능하고 커널에서 발생하는 대부분의 이벤트에 대해 분석이 가능해요.

25
00:03:12,000 --> 00:03:16,000
그 외에 제가 모르는 테크닉들이 많이 있겠죠?

26
00:03:16,900 --> 00:03:18,600
 그런데 만약에

27
00:03:19,800 --> 00:03:22,000
 앞에 보여 드렸던 이 상황이

28
00:03:23,100 --> 00:03:27,800
시스템이 부팅 할 때 발생한다면 고려해야 할게 더 많아 지거든요.

29
00:03:31,800 --> 00:03:45,400
GDB나 Strace, Ftrace 같은 툴들은 파일시스템 내에 저장되어 있는데 문제가 발생하는 시점에 해당 파일 시스템이 마운트 중이라면 사용하지 못하고요.

30
00:03:47,600 --> 00:03:52,500
타겟 프로세스와 디버거들 간의 실행 순서도 고려를 해야 돼요.

31
00:03:53,500 --> 00:04:02,200
 예를 들면 타겟이 실행 되기 전에 디버거들을 먼저 실행시키게 되면 분석이 불가능하겠죠?

32
00:04:04,300 --> 00:04:17,200
또한 임베디드 시스템에서는 보안을 위해 쉘 접근을 막아 놓는데 이러한 환경인 경우에 터미널을 통해 디버거를 실행하는게 불가능하겠죠.

33
00:04:19,600 --> 00:04:23,800
그 외에도 몇 가지 고려를 해야 하는 게 있을 거고요.

34
00:04:24,500 --> 00:04:32,800
문제 그 본질도 아니고 다른 부분에 에너지를 쏟아야 하니까 머리도 아프고 너무 귀찮아요.

35
00:04:34,800 --> 00:04:41,634
그러지 말고 원래 본질적인 문제에만 빨리 집중해서 끝내는게 좋겠죠?

36
00:04:44,700 --> 00:04:56,134
이 문제를 해결하기 위해 코드를 수정하는게 맞다면 커널에 있는 시그널 처리 루틴에 접근해서 분석하는게 더 효율적이지 않을까요?

37
00:04:58,200 --> 00:05:00,800
 저는 이렇게 생각해서 접근하게 되었고요.

38
00:05:03,200 --> 00:05:14,400
다시 여기에 두 개 프로세스가 있고 부모가 자식한테 시그널을 보내고 있어요 이는 유저 레벨에서 본 시그널이 처리되는 과정이고요

39
00:05:16,200 --> 00:05:18,400
실제로 커널은 이와 같아요.

40
00:05:18,400 --> 00:05:28,367
 부모는 Kill System-call을 통해 커널에게 시그널을 요청하고 커널은 시그널을 처리하여 자식에게 전달하게 되죠.

41
00:05:30,000 --> 00:05:36,700
이 커널 레벨을 좀 더 세분화 해보면 다음처럼 스테이지 세 개로 나눌 수가 있고요.

42
00:05:38,200 --> 00:05:42,900
세 개의 스테이지 중에 스테이지-3에서 코드를 수정 할 거예요.

43
00:05:44,900 --> 00:05:55,800
 '세 개의 스테이지가 있는데 왜 하필 스테이지 3에서 수정을 할까'라고 생각하실 수 있고요 그 첫 번째 이유로는 보안과 관련이 있어요.

44
00:05:56,800 --> 00:06:04,500
 커널은 사용자가 보내는 값에 대해 항상 예외 처리를 수행 해야 되는데요,

45
00:06:04,500 --> 00:06:15,000
예를 들면 사용자는 시그널 번호가 아닌 다른 정수값을 커널에게 전달할 수 있기 때문에 항상 확인을 해야 돼요.

46
00:06:16,800 --> 00:06:20,900
두 번째는 프로세스를 확인해야 하는데요,

47
00:06:20,900 --> 00:06:25,600
 타겟이 현재 시스템에 살아 있는지 확인하는 작업이고요.

48
00:06:25,600 --> 00:06:30,500
 해당 프로세스가 없다면 굳이 시그널을 처리할 필요가 없겠죠.

49
00:06:32,300 --> 00:06:39,200
 또한 하나의 프로세스의 쓰레드가 여러 개 있는 경우 어떤 쓰레드에 전달할 건지도 확인해야 하고요.

50
00:06:43,200 --> 00:06:46,800
 코드 레벨에서는 Null pointer를 체크해야 하고,

51
00:06:47,034 --> 00:06:53,400
 그 외에도 시큐리티 관련 이라든지 여러가지 사항들이 있겠죠.

52
00:06:56,700 --> 00:07:02,000
스테이지 3에서 하는 이유는 알겠는데 그럼 어떤 방식으로 수정을 해야 할까요?

53
00:07:03,000 --> 00:07:09,900
간단하게 살펴보면 첫 번째로는 트레이싱이 필요 없는 시그널은 전부 필터링 할 거예요.

54
00:07:12,000 --> 00:07:15,900
printk를 이용해서 콘솔로 출력을 할 거고요.

55
00:07:18,200 --> 00:07:27,400
내용에는 Sender에 프로세스 이름과 PID, Receiver에 프로세스 이름과 PID, 그리고 시그널 번호를 출력하고요.

56
00:07:28,200 --> 00:07:33,500
이는 앞서 살펴본 정보를 바탕으로 만든 간단한 패치인데요

57
00:07:33,500 --> 00:07:42,700
저는 SIGCHLD와 SIGALRM을 필터링하고 Sender와 Receiver, 그리고 시그널 번호를 출력하도록 수정했어요.

58
00:07:44,700 --> 00:07:49,500
 이 내용은 Kill System-call이 호출 되었을 때 실행되는 Kernel call stack 이고요,

59
00:07:49,500 --> 00:08:01,600
 스테이지 1과 2를 처리하고 난 뒤에 send_signal 함수 내에 complete_signal이 완료되고 나서 출력하도록 조정하였습니다.

60
00:08:02,600 --> 00:08:09,700
그럼 지금부터 앞서 설명드린 패치를 적용한 시스템을 이용하여 간단하게 보여 드리도록 하겠습니다.

61
00:08:18,000 --> 00:08:21,400
 이 터미널은 현재 라즈베리파이에 연결되어 있고요.

62
00:08:22,700 --> 00:08:24,800
 현재 재부팅을 수행하고 있고.

63
00:08:26,000 --> 00:08:28,200
부팅 후에 계속 설명드리도록 하겠습니다.

64
00:08:40,900 --> 00:08:47,600
이제 부팅이 완료 되었는데요 천천히 부팅 메시지를 분석하도록 하겠습니다.

65
00:08:54,300 --> 00:09:00,200
 여기 보시는 바와 같이 부팅 단계에서는 8 시스템이 초기화되기 전에.

66
00:09:01,400 --> 00:09:10,000
 위에 나와 있는 것처럼 시그널이 전송될 수 있기 때문에 앞서 설명드린 트레이싱 툴을 사용하는 게 어려운 환경이고요.

67
00:09:10,900 --> 00:09:17,900
 커널을 해킹해서 분석하게 되면 이처럼 손쉽게 확인할 수 있습니다.

68
00:09:19,200 --> 00:09:28,100
여긴 다시 한 번 말씀드리지만 여기 파일 시스템이 초기화되고 있고 그 이전에 시그널이 전송되는 메시지이고요

69
00:09:29,100 --> 00:09:37,800
그 다음에 쉘에서 kill 명령어를 통해 시그널을 날리도록 하겠습니다. 

70
00:09:38,800 --> 00:09:46,800
이 kill 명령어를 이용을 해서 저는 DHCP 클라이언트한테 시그널을 보내도록 할 거고요

71
00:09:47,500 --> 00:09:51,500
이제 명령어을 이용하여 시그널을 전달하도록 하겠습니다.

72
00:09:53,700 --> 00:10:04,700
그러면 커널 메시지에 보시는 바와 같이, 쉘에서 Sender는 쉘이 되는 거고 Reciever가 DHCP 클라이언트가 되는 거고요.

73
00:10:05,000 --> 00:10:13,200
SIGUSR1 시그널이 전달되는 것을 메시지를 통해 확인을 할 수가 있습니다.

74
00:10:16,100 --> 00:10:26,634
그 다음에는 재부팅 명령어를 통해서 재부팅을 할 때에, 시그널이 어떤 방식으로 동작을 하게 되는지 보여 드리도록 하겠습니다.

75
00:10:27,634 --> 00:10:31,500
재부팅 명령어를 수행을 했고요.

76
00:10:31,867 --> 00:10:32,600
이는

77
00:10:33,700 --> 00:10:38,200
 어느 정도 재부팅 프로세스가 완료가 되면 설명을 드리도록 하겠습니다.

78
00:10:54,800 --> 00:10:58,400
 현재 거의 재부팅이 완료가 된 상태구요.

79
00:10:59,300 --> 00:11:06,700
재부팅 명령어를 통해 나온 시그널 내용에 대해서 설명을 드리도록 하겠습니다.

80
00:11:07,400 --> 00:11:17,367
우선은 재부팅 명령어를 수행하게 되면 현재 시스템에 있는 전체 프로세스에게 시그널이 전송이 되게 되고요.

81
00:11:20,000 --> 00:11:24,534
 15번 같은 경우에는 SIGTERM 시그널 번호가 되는 거고요.

82
00:11:25,100 --> 00:11:32,100
그렇게 해서 완전히 프로세스가 종료 하게 되면은 재부팅을 수행하게 됩니다.

83
00:11:33,700 --> 00:11:46,400
따라서 커널을 해킹 하게 되면 재부팅을 하게 되면서 어떤 시그널이 날아가게 되는지 이런 한 것들도 분석을 할 수 있게 되고요.

84
00:11:50,200 --> 00:11:59,167
그래서 데모 시연은 이 정도로 해서 마치도록하고 다시 프레젠테이션으로 돌아가도록 하겠습니다.

85
00:12:03,900 --> 00:12:15,867
이번 세션은 커널에 대해 깊게 분석하기 보다는 넓게 어떠한 이슈가 있었고 그걸 해결하기 위해 커널을 수정해서 해결했다는 관점으로 설명을 드렸어요.

86
00:12:15,900 --> 00:12:20,800
여러분 들이 커널과 조금이라도 가까워지셨다면 다행이고요

87
00:12:21,667 --> 00:12:24,600
제 발표는 여기에서 마치도록 하겠습니다.

88
00:12:24,867 --> 00:12:26,034
 감사합니다.

