1
00:00:07,859 --> 00:00:11,850
안녕하세요 이번 우부콘 2021 아시아에서

2
00:00:11,850 --> 00:00:17,369
WSL 관련된 주제로 준비를 해서
발표를 하게 된 한국 WSL 사용자

3
00:00:17,369 --> 00:00:22,380
그룹에 남정현 이라고 합니다.
제가 오늘 소개하려는 내용은요

4
00:00:22,380 --> 00:00:26,730
WSL 에서 제공하는 윈도우 API를 이용해서

5
00:00:26,730 --> 00:00:31,380
통합 테스트를 만드는 방법에 대해서
그리고 어떻게 만들었는지 과정과

6
00:00:31,380 --> 00:00:35,820
실제로 개발을 했던 오픈소스 프로젝트에 대해서 간단하게 소개를 드리고

7
00:00:35,820 --> 00:00:40,167
데모를 보여드리는 세션을 준비를 했습니다.

8
00:00:42,700 --> 00:00:47,650
이 오늘 소개하려는 내용을 크게
5가지 인데요. 우선 제가 이 오픈소스

9
00:00:47,650 --> 00:00:52,090
프로젝트의 시작을 하게 됐던 배경, 그리고 WSL SDK 를 실제로

10
00:00:52,090 --> 00:00:56,950
사용하는 데모와 환경, 그리고 SDK 를 개발하는 과정에서 있었던

11
00:00:56,950 --> 00:01:03,130
여러 가지 문제점들을 해결했던 과정, 그리고 아직 WSL API가 모두 다

12
00:01:03,130 --> 00:01:07,570
공개됐다고 볼 수는 없는데요,
거기서 아쉬웠던 점들에 대해서 그리고

13
00:01:07,570 --> 00:01:13,540
향후 이제 이 프로젝트를 좀 더 개선할
수 있는 방향에 대해서 이야기를

14
00:01:13,540 --> 00:01:21,360
해보려고 5가지 파트로 나누어서
오늘 발표를 진행하려고 합니다

15
00:01:21,840 --> 00:01:26,040
우선 이 프로젝트를 시작하게 됐던
동기와 배경에 대해서 좀 이야기를

16
00:01:26,040 --> 00:01:29,330
해보려고 하는데요

17
00:01:29,420 --> 00:01:34,610
WSL을 저는 매우 잘 사용하고 있습니다. 그래서 당연히 이제 

18
00:01:34,610 --> 00:01:38,479
윈도우 클라이언트 OS 에서 WSL을 사용할 수 있으니

19
00:01:38,479 --> 00:01:42,920
윈도우 서버에서도 보통은 클라이언트에서 제공하는 기능을 제작을

20
00:01:42,920 --> 00:01:47,420
맞추어서 같이 제공을 하는 경향이
있기 때문에 윈도우 서버에도 같은

21
00:01:47,420 --> 00:01:52,460
기능이 있을 것이다 라고 생각을 하고
찾아보다 보니 

22
00:01:52,460 --> 00:01:57,110
마이크로소프트 DOCS 에 상당히
친절하게 윈도우 서버 에서 WSL을

23
00:01:57,110 --> 00:02:01,634
활성화 하려면 어떻게 해야 되는지
자세하게 단계별 가이드가 나와 있더라구요

24
00:02:01,634 --> 00:02:04,100
그런데 좀 흥미로웠던 부분은

25
00:02:04,100 --> 00:02:09,170
원래대로라면 이제 스토어를 통해서
WSL 배포판에 설치하는 것이 맞는데

26
00:02:09,170 --> 00:02:12,530
윈도우 서버는 모두들 이해하고 계시겠지만

27
00:02:12,530 --> 00:02:18,049
클라이언트용 앱스토어가 존재하지 않죠. 그래서

28
00:02:18,049 --> 00:02:22,760
그러면 WSL을 어떻게 배포를 하는 걸까, 새삼 궁금해졌습니다. 그래서

29
00:02:22,760 --> 00:02:29,540
내용을 문서로 자세히 읽어 보니까
이제 별도로 스토어에서 이제 따로

30
00:02:29,540 --> 00:02:35,870
해당 패키지 파일만. 즉, APPX 파일만 추출해 가지고 별도의

31
00:02:35,870 --> 00:02:39,530
서버에서 다운로드 받을 수 있게 그렇게 가이드를 하고 있더라구요.

32
00:02:39,530 --> 00:02:44,329
그래서 이제 이렇게 다운로드 받은 파일을 압축을 풀고

33
00:02:44,329 --> 00:02:50,239
압축 푼 파일 안에서 설치를 담당하는 부트스트래퍼를

34
00:02:50,239 --> 00:02:55,900
실행하는 그런 구조로 되어 있었습니다.
그런데 이제 좀 흥미로웠던 것은

35
00:02:55,900 --> 00:03:02,370
패키지의 압축을 풀고 나서 보니까
install.tar.gz 라고 하는 파일이

36
00:03:02,370 --> 00:03:08,379
만들어져 있었더라구요. 근데 이 파일은
root 파일 시스템이라 그래서 리눅스

37
00:03:08,379 --> 00:03:14,049
유저 랜드 영역에 해당되는 모든
파일과 제 각종 콘텐츠들을 한꺼번에

38
00:03:14,049 --> 00:03:19,390
담고 있는 그런 컨테이너 포맷이라고
볼 수 있습니다. 그런데 이것을 그대로

39
00:03:19,390 --> 00:03:24,549
설치해서 사용하는 것을 보고 상당히
인상 깊었고 흥미로웠습니다.

40
00:03:24,549 --> 00:03:30,430
그래서 만약에 이 이미지 파일 자체를
내가 원하는 형태로 커스터마이징을

41
00:03:30,430 --> 00:03:35,799
할 수 있다면 괜찮지 않을까, 흥미롭지
않을까, 그런 생각을 하게 되었는데요.

42
00:03:35,799 --> 00:03:40,934
그래서 좀 더 자세히 찾아본다면
내가 원하는 형태로 WSL을

43
00:03:40,934 --> 00:03:47,867
제공된 패키지 이상의 형태로 다듬거나
자동화를 하는 것이 어쩌면 가능하지 않을까.

44
00:03:47,867 --> 00:03:51,989
그런 배경을 가지고 
시작을 하게 됐습니다.

45
00:03:53,300 --> 00:03:59,200
그래서 조금 더 찾아보니 wslapi.h 라고 하는 헤더 파일이

46
00:03:59,200 --> 00:04:03,050
SDK에 들어 있었고요.
상당히 흥미로운 그런 함수들과

47
00:04:03,050 --> 00:04:06,170
헤더 정의가 포함이 되있었습니다.

48
00:04:06,170 --> 00:04:10,820
그래서 이 API들이 가끔 어떤 역할을 하는지 자세히 알아보고

49
00:04:10,820 --> 00:04:15,870
테스트해보기 시작을 하게 되었죠.
그래서 제가 세웠던 가정은 크게

50
00:04:15,870 --> 00:04:19,549
3가지입니다.
하나는 이제

51
00:04:19,549 --> 00:04:24,300
이미지를, 윈도우의 경우에는 윈도 이미지가 이쪽

52
00:04:24,300 --> 00:04:28,440
그리고 리눅스의 경우에 리눅스 이미지가 있는데 이런 이미지를 그 os

53
00:04:28,440 --> 00:04:33,360
이미지를 내가 원하는대로 창작을 할 수 있다면, 그리고

54
00:04:33,360 --> 00:04:37,710
이렇게 만들어진 이미지를 이용해서
WSL 배포판을 내가 원할때 등록하고

55
00:04:37,710 --> 00:04:42,240
자유롭게 해제 할 수 있다면 어떨까,
마지막으로 이제 이렇게 등록한

56
00:04:42,240 --> 00:04:48,150
인스턴스를 내가 아무 때나
윈도우 측에서 명령어를 보내고

57
00:04:48,150 --> 00:04:52,869
받을 수 있는 그런 수단이 있다고 한다면

58
00:04:52,869 --> 00:04:58,089
이러한 수단들을 활용을 해서 자동화된
테스트 환경. 즉, 통합 테스트 라고

59
00:04:58,089 --> 00:05:03,789
우리가 부르는 완전한 테스트 환경을
VM이 라던가 아니면 Cygwin과 같이

60
00:05:03,789 --> 00:05:10,079
좀 다른 형태로 변형된, 혹은 원래의 리눅스에 가장 가깝긴 하지만

61
00:05:10,079 --> 00:05:15,099
구동하는데 오버헤드가 많이 드는 그런 환경보다 더 간편하고 빠르게

62
00:05:15,099 --> 00:05:20,199
리눅스 OS를 테스트할 수 있는 구체적인 방법이, 현실적인 방법이

63
00:05:20,199 --> 00:05:23,919
만들어 지는게 아닐까 그런 상상을 해보게 되었구요.

64
00:05:23,919 --> 00:05:28,989
동시에 이제 이렇게 만들어진 WSL의 자동화 환경을 이용해서

65
00:05:28,989 --> 00:05:34,059
생산성도 향상할 수 있다면 좋지 않을까, 그런 생각을 하면서 프로젝트를

66
00:05:34,059 --> 00:05:37,319
시작하게 되었습니다.

67
00:05:39,440 --> 00:05:45,350
그래서 github.com/wslhub/wsl-sdk-com 이라는

68
00:05:45,350 --> 00:05:51,740
이름으로 SDK 프로젝트를 처음 개발을 해서 현재 어느 정도 완성된

69
00:05:51,740 --> 00:05:55,900
상태로 코드를 올려 두었습니다.

70
00:05:56,210 --> 00:06:01,820
그래서 이 프로젝트, 이 SDK를 가지고서 무엇을 할 수 있냐면

71
00:06:01,820 --> 00:06:08,267
컴을 지원하는 모든 언어들을 사용 하셔서요, WSL 배포판을 원하는 대로 등록하고

72
00:06:08,267 --> 00:06:12,470
수정하고 삭제하는 것이 가능하고, 현재 어떤 배포판 들이

73
00:06:12,470 --> 00:06:18,200
설치가 되어있고 또 배포판 별로 이제
파일 시스템이 각각 따로따로 존재를 해요.

74
00:06:18,200 --> 00:06:23,240
그래서 각각의 파일 시스템과
윈도우 8 시스템 사이의 경로로

75
00:06:23,240 --> 00:06:28,934
상호 변환 해서 프로그래밍 방식으로
경로를 조립해서 WSL 안으로 파일을 넣거나

76
00:06:28,934 --> 00:06:34,070
혹은 바깥으로 빼 울 때 경로 문제에서 조금 더 편리하게

77
00:06:34,070 --> 00:06:38,000
개발을 하고 안정적으로 개발할 수 있도록 도와주는 그런 수단을 가지고 있고요,

78
00:06:38,000 --> 00:06:41,060
마지막으로 통합 테스트 자동화를

79
00:06:41,060 --> 00:06:46,940
목적으로 고민을 하던 주제가 하나 있었는데, 배포판의 이름을 사실

80
00:06:46,940 --> 00:06:52,370
기본 단위로 WSL 에서 사용하기 때문에 배포판의 이름을

81
00:06:52,370 --> 00:06:57,080
동적으로 만들어낼 필요가 있었어요.
하지만 그런 동적으로 이름을

82
00:06:57,080 --> 00:07:01,910
만들어 내는 것 뿐만이 아니라 사람이 기억하고 파악하기 쉬운 그런 이름을

83
00:07:01,910 --> 00:07:07,430
만들어야 했었기 때문에
관련해서 좋은 방법을 고민을 해보다가

84
00:07:07,430 --> 00:07:11,430
도커에서 컨테이너를 만들면

85
00:07:11,430 --> 00:07:16,980
과학계에 공헌한 사람과 사람의 이름 앞에 간단한

86
00:07:16,980 --> 00:07:21,860
형용사 같은걸 붙여서 임의로 이름 작명을 하는, 한편으로는

87
00:07:21,860 --> 00:07:26,634
사람이 읽고 이해하기 쉬운 그런 닉네임을 자동으로 붙여 주는

88
00:07:26,634 --> 00:07:31,800
모듈이 있더라구요. 그래서 모듈을 가지고 와서 포팅을 해서 여기에

89
00:07:31,800 --> 00:07:35,580
적용을 해 볼 수 있었습니다. 그래서 이러한 기능들을

90
00:07:35,580 --> 00:07:39,780
아무런 제약 조건이나 귀찮은 부분 없이 자유롭게 쓸 수 있도록

91
00:07:39,780 --> 00:07:44,150
만들었다는 것이 SDK의 특징이구요.

92
00:07:44,259 --> 00:07:51,300
그래서 sdk 가 실제로 어떻게 동작하는지 구체적인 내용을 살펴보려고 합니다.

93
00:07:52,290 --> 00:07:57,550
SDK는 크게 아까 말씀드렸던 대로 이렇게

94
00:07:57,550 --> 00:08:01,870
6가지 파트로 기능을 나누어서 제공하고 있는데요.

95
00:08:01,870 --> 00:08:05,340
하나씩 살펴보도록 하겠습니다.

96
00:08:06,540 --> 00:08:13,120
SDK를 우선은 사용하기에 앞서서 초기화를 해야 되는 문제가 있습니다.

97
00:08:13,120 --> 00:08:15,870
이 부분은 뒤에서도 다시 말씀 드릴텐데요.

98
00:08:15,870 --> 00:08:21,500
사실 WSL API 가 지금 마이크로소프트 Docs에

99
00:08:21,500 --> 00:08:26,320
공개가 되어 있는 API 기준으로 얘기를 하면 사실 API는

100
00:08:26,320 --> 00:08:32,979
내부적으로 LXSS 매니저라고 하는 컴포넌트를 단순히

101
00:08:32,979 --> 00:08:37,000
바깥에서 맵핑을 한 API에 불과합니다. 그렇기 때문에

102
00:08:37,000 --> 00:08:41,534
이 API를 보통 우리가 생각하는 윈도우 API 처럼 그냥 부를 수는 없고요.

103
00:08:41,534 --> 00:08:44,567
반드시 CoinitializeSecurity 라고 하는

104
00:08:44,567 --> 00:08:49,630
COM 관련 보안 모델 초기화 하는 함수를 한번은 불러야 됩니다.

105
00:08:49,630 --> 00:08:54,934
그런데 이제 이 함수는 어디서든지 한 번 이상 부르고 나면 다시 부를 수가 없습니다.

106
00:08:54,934 --> 00:08:58,110
그렇기 때문에 이제

107
00:08:58,110 --> 00:09:04,120
대표적인 사례가 LINQPad나 Power Shell 같이 COM 기술을 의존을 하는 그런

108
00:09:04,120 --> 00:09:09,120
환경에서는 WSL API를 C언어 형태로

109
00:09:09,120 --> 00:09:14,900
dll 함수 형태로 가지고 와서 부를 수 있는 거랑은 별개로, 부르려고 할 때

110
00:09:14,900 --> 00:09:20,589
access denied 에러 코드가 떨어지게 되요. 그래서 이 부분을

111
00:09:20,589 --> 00:09:23,890
극복을 하려면 어떻게 해야 될까 고민을 하다가

112
00:09:23,890 --> 00:09:29,667
뒤에 가서 다시 말씀드리겠지만 단순히 프로세스 바깥으로 꺼내는 것 뿐만이 아니라 

113
00:09:29,667 --> 00:09:35,134
기존의 떠 있는 프로세스와 새로 만든 WSL SDK 만을 호스팅 하는

114
00:09:35,134 --> 00:09:39,580
프로세스가 서로 유기적으로 어떠한 사전 정보나

115
00:09:39,580 --> 00:09:43,510
구체적인 정보가 없이도 스무스 하게 통신할 수 있는 그런

116
00:09:43,510 --> 00:09:48,867
방법을 한참 고민을 하다가, 좀 오래된 개념이긴 하지만, 여전히 유요한

117
00:09:48,867 --> 00:09:55,890
Out of Process COM 모델을 본격적으로 도입을 하게 되었습니다.

118
00:09:57,030 --> 00:10:01,900
그리고 이제 앞서도 이야기 드렸지만
랜덤으로 이름 생성을 하는 부분은

119
00:10:01,900 --> 00:10:06,210
단순히 GUID 값을 임의로 붙이는 것이 중요한 게 아니기 때문에

120
00:10:06,210 --> 00:10:12,270
도커 컨테이너에 names generator 라고 하는 고래 으로 되어있는 모듈이

121
00:10:12,270 --> 00:10:18,950
마침 있어서, 이 부분을 간편하게 C#으로 포팅해서 적용할 수 있었습니다.

122
00:10:20,680 --> 00:10:26,560
그리고 이제 이 리눅스를 사실 설치를
해야 되기 때문에 이 리눅스를 그래서

123
00:10:26,560 --> 00:10:46,389
어디서 가지고 올 것이냐, 라고 하는 문제도 같이 고민해 봤었어야 됐는데요. 그래서 좀 찾아보다 보니 사실 WSL에는 루트 파일 시스템이기만 하면 그것이 어떤 리눅스 배포판이든 간에 자유롭게 이제 설치하고 사용할 수 있도록 되어 있습니다.

124
00:10:46,389 --> 00:10:56,334
그래서 BusyBox와 같이 정말 경량화된 그런 리눅스 운영체제도 WSL 안에서 사용할 수 있도록 당연히 구비가 되어 있었구요.

125
00:10:56,334 --> 00:11:03,667
뿐만 아니라 이제 도커에서 요즘 사용중인 초 경량화 운영체제 알파인 리눅스를

126
00:11:03,667 --> 00:11:10,870
WSL로 다른 분께서 포팅을 잘해 주신 것이 있어 가지고, 이것도 잘 사용할 수 있었습니다.

127
00:11:10,870 --> 00:11:17,139
그래서 이 프로젝트에서 내부적으로 BusyBox 와 알파인을 이용해서

128
00:11:17,139 --> 00:11:23,334
유닛테스트. 즉, 이 API가,  SDK가 제공하는 기능이 정상 동작하는 지를 검증할 때

129
00:11:23,334 --> 00:11:27,190
그 때 알파인과 BusyBox.

130
00:11:27,190 --> 00:11:31,600
rootfs이미지를 사용해서 우분투나 데비안을 사용하게 되면

131
00:11:31,600 --> 00:11:36,250
이미지 사이즈가 보통 크기 때문에 그보다
훨씬 빠르고 정확하게 그러면서도

132
00:11:36,250 --> 00:11:40,690
목적을 달성할 수 있게 그런 유닛테스트를 만들 수 있었습니다.

133
00:11:40,690 --> 00:11:43,449
그리고 하나 더 말씀드릴 것이 있는데요.

134
00:11:43,449 --> 00:11:49,089
이제 우분투에 경우에는 아마 우분투 이외의 다른 리눅스도 마찬가지일 텐데

135
00:11:49,089 --> 00:11:55,180
이렇게 미리 만들어진 WSL용을 위한 것은 아닙니다만

136
00:11:55,180 --> 00:12:00,040
루트 파일시스템을 각 아키텍처 별로 미리 만들어서 배포를 하곤 하는데요

137
00:12:00,040 --> 00:12:03,790
이것이 WSL용으로 선언이 된 적은 없어도 기술적으로 호환이

138
00:12:03,790 --> 00:12:08,700
가능하기 때문에 WSL에서 얼마든지 이렇게 만들어진 루트 이미지를

139
00:12:08,700 --> 00:12:13,230
가지고 와서 사용할 수 있게 되어 있습니다.

140
00:12:15,329 --> 00:12:20,639
그리고 좀 더 흥미로운 주제를 하나 더 보여드리려고 하는데요.

141
00:12:20,639 --> 00:12:26,220
도커를 많이들 사용하실 겁니다. 근데 이제 도커도 내부적으로는

142
00:12:26,220 --> 00:12:30,629
이렇게 멀티 레이어로 구성되어 있는 이미지를 사용 하지만, 실제로는

143
00:12:30,629 --> 00:12:36,329
한번 만들어진 컨테이너를 rootfs 형태로 익스포트를 할 수 있는

144
00:12:36,329 --> 00:12:39,629
그런 기능을 가지고 있습니다. 그래서

145
00:12:39,629 --> 00:12:46,300
특별한 작업하는 것 없이 그냥 임의로 컨테이너를 하나 만들었고 바로 종료가 된 상태에서 

146
00:12:46,300 --> 00:12:52,734
(명령어) docker export -o mylinux.tar.gz ubuntu1804 

147
00:12:52,734 --> 00:12:59,290
라고 해서 이렇게 루트 이미지 경로 지정 해 주시고 ubuntu1804를 내보냈습니다.

148
00:12:59,290 --> 00:13:04,019
그 다음에 만들어진 이미지 파일을 확인을 하구요.

149
00:13:07,910 --> 00:13:15,340
실제로 이 파일이 어떻게 구성되어 있는지 보면 전형적인 루트 파일 시스템이 것을 확인할 수 있습니다.

150
00:13:15,380 --> 00:13:22,149
그리고 WSL에 임포트를 시키기 위해서 특정한 경로에다가

151
00:13:22,860 --> 00:13:27,120
인스톨을 할 수 있게 임포트 명령을 써서

152
00:13:27,120 --> 00:13:30,740
rootfs이미지를 가지고 오려고 합니다.

153
00:13:30,740 --> 00:13:38,400
WSL2 로 가지고 오려고 하는 거고요.
그러면 이렇게 잘 임포트가 된것을 볼 수 있고

154
00:13:38,400 --> 00:13:44,209
실제로 실행을 해보면 잘 동작하는 것을 알 수 있습니다.

155
00:13:50,980 --> 00:13:56,770
그래서 etc os release 확인해보면 18.04 도커 이미지를

156
00:13:56,770 --> 00:14:05,910
그대로 잘 갖고 온 것을 알 수 있구요.
그리고 테스트가 끝나서 unregister 까지 잘 해주었습니다.

157
00:14:07,760 --> 00:14:12,200
네 이렇게 해서 리눅스 파일 시스템을 도커로부터

158
00:14:12,200 --> 00:14:17,780
도커 파일을 가지고서 여러분께서 원하시는 WSL 이미지 파일을 빌드를 한 다음에

159
00:14:17,780 --> 00:14:21,950
이것을 WSL로 내보내기만 하면 누구나

160
00:14:21,950 --> 00:14:27,300
간편하게 WSL 루트 파일 시스템을 제작을 하고

161
00:14:27,300 --> 00:14:33,350
전용 배포판을 쉽게 저작을 할 수 있는
그런 가능성도 볼 수 있었습니다.

162
00:14:33,350 --> 00:14:37,310
그래서 이처럼 유연한 리눅스 파일 시스템을 이용을 해서요.

163
00:14:37,310 --> 00:14:42,130
도커 컨테이너 이미지로, 
방금 전에는 내보내는 것만 보여 드렸는데

164
00:14:42,130 --> 00:14:46,640
반대로 도커 컨테이너 이미지에서, 
물론 레이어가 살아 있는 것은 아니지만

165
00:14:46,640 --> 00:14:54,167
어쨌든 그 기반이 된 루트 이미지를 바로 컨테이너 이미지로 변환할 수 있습니다.

166
00:14:54,167 --> 00:14:57,600
이렇게 이미지를 임포트를 하고 난 다음에

167
00:14:57,600 --> 00:15:03,290
다른 도커 파일에서 또 다른 베이스 이미지를 또 사용할 수 있는 그런 기능이 있죠.

168
00:15:03,290 --> 00:15:12,010
그리고 방금 보여 드렸던 것처럼 이미지를 임포트 하는 시점에서 
WSL 버전도 같이 선택할 수가 있습니다.

169
00:15:13,870 --> 00:15:18,834
그리고 WSL에 명령어를 바로 전달하고 

170
00:15:18,834 --> 00:15:22,360
그 안에 해석기가 직접 명령어를 실행할 수 있게끔

171
00:15:22,360 --> 00:15:26,867
그렇게 하는 방법에 대해서도
프로그래밍 방식으로 이걸 처리하는 것에 대해서

172
00:15:26,867 --> 00:15:32,139
조금 많이 찾아봤는데요.
기본적으로 이제 여기서 사용하는 것은

173
00:15:32,139 --> 00:15:36,579
우리가 윈도우 프로그래밍 할때 많이
활용을 하는 부분이죠.

174
00:15:36,579 --> 00:15:41,319
익명 파이프 라고 해서 네임드 파이프와 익명 파이프가 있죠.

175
00:15:41,319 --> 00:15:46,400
여기서 익명 파이프로 사용을 해서 프로세스에다가 

176
00:15:46,400 --> 00:15:52,630
STDIN, STDOUT, STDERR 요거에 해당되는 각각의 익명 파이프를

177
00:15:52,630 --> 00:15:58,367
만들어서 제공을 해주고 input은 input 대로 들어오고

178
00:15:58,367 --> 00:16:02,350
STDOUT, STDERR는 따로따로 캡처를 해서

179
00:16:02,350 --> 00:16:09,670
각각 문자를 나누어서 되돌려 주는 그런 API 를 개발을 해서

180
00:16:09,670 --> 00:16:13,319
집어 넣게 되었죠.

181
00:16:14,350 --> 00:16:18,820
그래서 이제 실제 데모 영상을 조금 준비를 해보았는데요.

182
00:16:18,820 --> 00:16:22,350
하나씩 좀 살펴보도록 하겠습니다.

183
00:16:24,670 --> 00:16:30,279
우선은 이게 COM API 로 디자인이 되어 있기 때문에 가장

184
00:16:30,279 --> 00:16:34,960
대표적이죠. 오피스에서 VB Script를 이용해서

185
00:16:34,960 --> 00:16:39,880
COM 방식으로 리모트 커맨드를 WSL로 보내서

186
00:16:39,880 --> 00:16:46,089
실행하2 데모를 준비를 했습니다. 그래서 보시는 것처럼 이렇게 

187
00:16:46,089 --> 00:16:50,320
STDOUT으로 나오는 데이터를 받아가지고

188
00:16:50,320 --> 00:16:55,610
스프레드시트 셀에 붙여 넣는 그런 모습을 보여드렸는데요.

189
00:16:55,610 --> 00:17:01,940
이처럼 WSL 에서 만들어내는 output String을 어디서든

190
00:17:01,940 --> 00:17:08,110
가지고 와서 사용할 수 있는 그런 유연한 기능을 제공하고 있습니다.

191
00:17:10,000 --> 00:17:16,340
그리고 당연히 PowerShell에서도 비슷한 기능을 이용하실 수가 있는데요.

192
00:17:16,340 --> 00:17:20,660
PowerShell Script를 이용해서

193
00:17:20,660 --> 00:17:25,580
알파인 리눅스 루트 파일을 가지고 와서 동적으로 추가를 하고

194
00:17:25,580 --> 00:17:35,290
그리고 설정 값들을 확인을 해 보고요.
그리고 내부적으로 Vim을 설치해서

195
00:17:38,350 --> 00:17:46,300
실행이 잘 되는 것을 볼 수 있습니다.
패키지 매니저가 그대로 실행이 잘되고 있구요, 그리고

196
00:17:46,300 --> 00:17:51,234
사용의 다 끝나서 해당 배포판을 언인스톨 하는 것까지

197
00:17:51,234 --> 00:17:59,730
이렇게 진행을 했고 현재 제가 먼저 설치해서 사용하던 
우분투 리눅스 배포판만 남은 걸 보실 수 있습니다.

198
00:18:01,190 --> 00:18:06,534
그리고 파이썬에 PyWin32 라고 하는 확장 모듈 안에

199
00:18:06,534 --> 00:18:12,500
COM에 관련된 그런 내용이 이미 포함 되있습니다. 그래서 마찬가지로 파이썬에서도

200
00:18:12,500 --> 00:18:17,090
WSL SDK API를 이용해서

201
00:18:17,090 --> 00:18:21,529
원하는 작업을 앞서 보여드렸던 PowerShell과 비슷한 형태로

202
00:18:21,529 --> 00:18:27,400
테스트를 해 볼 수 있습니다.
그래서 WSL 배포판을 Jupyter Notebook을 이용해서

203
00:18:27,400 --> 00:18:38,559
인터랙티브한 방식으로 설치해서 사용하고 
테스트할 수 있게 이렇게 샘플 만들어 보았구요. 
마찬가지로 잘 실행되는 것을 볼 수 있습니다.

204
00:18:46,299 --> 00:18:55,529
그래서 배포판 런처까지 이렇게 자동으로 만들어서 실행되는 모습도 보여주고 있구요.

205
00:18:57,840 --> 00:19:04,309
여기까지 파이썬을 이용해서 데모를 보여드렸습니다.

206
00:19:04,800 --> 00:19:08,730
마지막으로 이제 유닛테스트를 이렇게 만들었는데요.

207
00:19:08,730 --> 00:19:15,900
유닛테스트는 비주얼 스튜디오에서 닷넷으로
실행이 되는 형태로 그렇게 지금 만들어져 있는데,

208
00:19:15,900 --> 00:19:21,234
유닛테스트 자체가 사실 그냥 닷넷 런타임을 바로 실행하는 그런 구조가 아니고,

209
00:19:21,234 --> 00:19:26,167
사실은 비쥬얼 스튜디오 안에 관리 프로세스의 내부에서 실행이 되는 것이기 때문에

210
00:19:26,167 --> 00:19:30,900
닷넷 코드만 실행할 때에는 상관이 없지만 이처럼

211
00:19:30,900 --> 00:19:35,760
COM과 연동이 되서 복잡한, 그런 보안 모델을 사용하는 경우에는

212
00:19:35,760 --> 00:19:41,700
아까 말씀드렸던 대로 LINQPad나 PowerShell 처럼 COM 관련 보안 모델이

213
00:19:41,700 --> 00:19:45,780
이미 사용하고 있는 것이기 때문에 이것을 WSL 에 맞춰서

214
00:19:45,780 --> 00:19:52,034
오버라이딩 하는게 어렵습니다. 이런 부분들을 Out of Process 형태로 해서 빼고

215
00:19:52,034 --> 00:19:57,810
내부 SDK 에서는 COM API 와 통신 하도록

216
00:19:57,810 --> 00:20:05,200
그렇게 제공하고 있기 때문에 유닛 테스트에서는 단순하게 클라이언트 형태로

217
00:20:05,200 --> 00:20:09,309
이것을 활용해서 사용하기만 하면 되는 형태가 됩니다.

218
00:20:09,309 --> 00:20:13,140
그리고 하나 더 말씀드릴 것이 있었는데요.

219
00:20:13,140 --> 00:20:19,260
아까전에 파이썬에서 제가 미리 준비한 동영상에서

220
00:20:19,260 --> 00:20:23,780
잠깐 언급하고 넘어가고 싶은 부분이 있습니다.

221
00:20:26,119 --> 00:20:35,869
뒤에서 말씀드리겠지만 이런 런처를 사실은 처음에 만들 필요가 없지 않을까? 
라고 생각을 했었는데요. 정말 놀랍게도

222
00:20:35,869 --> 00:20:39,799
WSL register distribution 이라고 하는 API 는

223
00:20:39,799 --> 00:20:43,867
배포판을 디자인 하는 사람들을 위해서

224
00:20:43,867 --> 00:20:48,679
공개가 된 API 였습니다. 그래서 다른 형태로 API를

225
00:20:48,679 --> 00:20:54,267
우리가 아까 봤던 WSL 임포트 명령어처럼 그렇게 API를 사용할 수가 없었고

226
00:20:54,267 --> 00:21:00,000
반드시 API를 부르는 그런 실행 주체가 이제 어느 exe 파일에,

227
00:21:00,000 --> 00:21:03,949
어느 파일 시스템 경로 상에 들어 있는지를 확인해서 거기에다가

228
00:21:03,949 --> 00:21:09,949
무조건 WSL 배포판은 제
이미지를 풀고 설치하는데 그런 동작을

229
00:21:09,949 --> 00:21:14,029
가지고 있더라구요. 그래서 그 동작이

230
00:21:14,029 --> 00:21:19,879
제가 원하는 형태의 동작은 아니었기 때문에 결국은 이 API 를

231
00:21:19,879 --> 00:21:25,309
부르는 별도의 주체가 반드시 작든 크든 exe 파일이

232
00:21:25,309 --> 00:21:29,239
별도로 나와 있어야 한다 라는 그런 특이한 제약조건이 있었구요.

233
00:21:29,239 --> 00:21:33,933
좀 안타까웠던 것을 Docs에 이런 부분에 대한 구체적인 설명이 없었습니다.

234
00:21:33,933 --> 00:21:41,169
이것을 이제 알아내는 데 다소 시행착오가 있었던 부분이 생각이 나네요.

235
00:21:42,430 --> 00:21:47,140
예. 그래서 이어서 말씀드리면 아까 말씀드렸던 것처럼

236
00:21:47,140 --> 00:21:52,290
CoinitializeSecurity라고 하는 API를 두 번 부를 수 없기 때문에

237
00:21:52,290 --> 00:21:59,433
그런 환경상의 제약이 존재를 했고 결국은 이 문제를 해결하기 위해서

238
00:21:59,433 --> 00:22:07,140
별도의 프로세스에서 WSL API를 부르는 형태로 갈 수밖에 없었다. 
라는 결론에 이르게 됐습니다.

239
00:22:08,440 --> 00:22:17,590
그래서 COM 모델에 대해서 익숙하지 않으신 분들을 위해서 조금 더 말씀을 드리면요,
일단 COM은 기본적으로

240
00:22:17,590 --> 00:22:22,320
인프로세스 모델로 제일 많이 배포가 됩니다. 그래서

241
00:22:22,320 --> 00:22:28,540
원래는 DLL을 프로세스 안에 로딩을 해서 

242
00:22:28,540 --> 00:22:33,100
사용할 수 있도록 하는데 이게 기존에는 C언어 형태로

243
00:22:33,100 --> 00:22:40,867
API 함수들에 익스포트를 하게 되면 보통은 
헤더 파일에서 이러이러한 함수 시그니처가 

244
00:22:40,867 --> 00:22:48,370
반환 형태가 어떻게 되고, 호출 정리는 어떻게 해줘야 되고, 
이름은 무엇이고, 인자 구성을 어떻게 되고 하는 것들을

245
00:22:48,370 --> 00:22:58,360
기계어 형태로 프로토콜을 맞추어서 서로 헤더 파일을 가지고 있다 
라는 전제 아래에서 교환에서 사용하는 형태를 많이 이용했는데요.

246
00:22:58,360 --> 00:23:02,350
이러다 보니까 C 언어가 아닌 다른 언어들이나

247
00:23:02,350 --> 00:23:08,020
아니면 프로세스나 시스템의 경계를 넘어가는 상황에서는 함수를 어떻게

248
00:23:08,020 --> 00:23:12,790
불러야 될 것인지에 대한 명확한 규정이나 근거가 빈약했습니다. 그래서

249
00:23:12,790 --> 00:23:18,640
이런 부분들을 이제 본격적으로 해소할
수 있도록 타입 라이브러리 개념을

250
00:23:18,640 --> 00:23:27,867
도입을 하고 또 dll 을 이제 좀 더 객체지향의 형태로 
잘 부르고 관리할  수 있도록 하기 위해서 
COM 이라고 하는 모델을

251
00:23:27,867 --> 00:23:35,200
Win32 까지, 정확하게는 Windows 95가 시작이 될 무렵부터 도입을 해서

252
00:23:35,200 --> 00:23:40,120
많이 사용을 했고요, 그리고 그것이 이제 인터넷 기술과 연결이 돼서 우리가

253
00:23:40,120 --> 00:23:49,680
지금 그토록 문제시하는 엑티브엑스 기술이 바로 이 COM 기반으로 하는 부분입니다.
그런데 이 프로세스의 방식으로는

254
00:23:49,680 --> 00:23:57,390
앞서 말씀드렸던 대로 WSL SDK가 원하는 바를 
달성할 수 없었기 때문에 이 부분 해소를 하기 위해서

255
00:23:57,390 --> 00:24:06,170
외부 프로세스로 빼면서도 그런 와중에 또 COM을 사용한다 라면 자명한 부분이

256
00:24:06,170 --> 00:24:12,990
이런 내부에 어떤 식으로 이제 구현이 되어 있든, 바깥에서는 무조건

257
00:24:12,990 --> 00:24:18,060
COM 인터페이스 객체를 받아와서
사용할 수 있다, 이것만 확실하다면

258
00:24:18,060 --> 00:24:22,230
언제 어디서나 어떻게 불러도 자유롭게 쓸 수 있다. 
라는 걸 보장 할 수 있는

259
00:24:22,230 --> 00:24:25,830
그런 메카니즘을 가져왔어야 했기 때문에

260
00:24:25,830 --> 00:24:30,133
네트워크 포트가 몇 번이고. 서버가 몇 대가 또 있고 이런 부분들에 대해서

261
00:24:30,133 --> 00:24:34,470
유연하게 대처를 할 필요가 있었습니다. 그러다가 한참 찾다가

262
00:24:34,470 --> 00:24:39,420
결국은 Out of Process 모델이 제가 원하는 바를 이루어 줄 수 있는

263
00:24:39,420 --> 00:24:42,660
방안이 겠구나. 
라는 결론을 내리게 됐습니다

264
00:24:42,660 --> 00:24:45,840
그런데 정말 다행스럽게도

265
00:24:45,840 --> 00:24:50,250
Out of Process 방식으로 뭔가 구현체를 만들려고 보니까 정말 예제가

266
00:24:50,250 --> 00:24:55,050
드물더라구요. 그런데 마이크로소프트가 아주 예전에

267
00:24:55,050 --> 00:24:58,890
All-In-One 코드 프레임워크 라고 하는 오픈소스 프로젝트를

268
00:24:58,890 --> 00:25:05,070
지금은 이제 모두들 아시다시피 Github에다가 모든 오픈 소스를

269
00:25:05,070 --> 00:25:09,967
올리는 시대가 되었죠. 근데 이 당시만 하더라도 굉장히 옛날인데

270
00:25:09,967 --> 00:25:14,730
코드 플렉스 라고 해서 마이크로소프트가 손수 운영 오픈소스 사이트. 저장소가

271
00:25:14,730 --> 00:25:18,360
있었습니다. 올해 여름에 종료가 됐죠. 그래서

272
00:25:18,360 --> 00:25:22,790
코드 플렉스에 올라와 있던 All-In-One 코드 프레임워크를 찾아서

273
00:25:22,790 --> 00:25:28,620
거기서 제가 원하는 Out of Process COM 서버에 구현체가, 그것도 C#으로만 

274
00:25:28,620 --> 00:25:31,860
구현되어 있는 것을 정말 운좋게 찾아냈습니다.

275
00:25:31,860 --> 00:25:36,300
당시에 코드 플렉스가 이미 닫혀 있었기 때문에 Github에서 다른

276
00:25:36,300 --> 00:25:44,000
포크 버전을 찾아 가지고 거기서 원하는 소스를 발췌해서 사용할 수 있었구요.

277
00:25:44,450 --> 00:25:49,279
그래서 이제 이렇게 예제를 가지고 와서 앞서 보여드렸던 각종

278
00:25:49,279 --> 00:25:53,367
기능들을 수행하는 그런 API를 디자인하게 됐습니다.

279
00:25:53,367 --> 00:25:59,140
근데 이제 여기서 궁금하게 생각하시는 분들이 계실 수 있는데, 
왜 아직 닷넷 프레임워크를

280
00:25:59,140 --> 00:26:03,500
사용하는지에 대해서 잠깐 언급 하려고 합니다.

281
00:26:03,500 --> 00:26:08,150
일단 닷넷 프레임워크는 모두들
아시다시피 윈도우의 거의 붙박이로

282
00:26:08,150 --> 00:26:16,333
붙어 있는 그런 프레임워크 입니다.
그래서 닷넷을 사용하는 가장 큰 이유 중에 하나가

283
00:26:16,333 --> 00:26:19,533
윈도우의 들어가는 그런 고급 기술들. 예를들면

284
00:26:19,533 --> 00:26:23,600
NT 서비스 라던가, COM 서버 라던가, 이런 부분들을

285
00:26:23,600 --> 00:26:28,250
C#과 닷넷 런타임에 기능만으로 복잡한

286
00:26:28,250 --> 00:26:34,300
C++ 프로그래밍을 하지 않고서도
플런트하게 프로그래밍할 수 있기 때문에 많이 이용했는데요

287
00:26:34,300 --> 00:26:37,933
지금 여기서도 Out of Process COM 서버를 비롯해서

288
00:26:37,933 --> 00:26:41,450
각종 레지스트리 다루는 부분이 라던가, 타임 라이브러리

289
00:26:41,450 --> 00:26:46,429
자동생성 이라던가, 이런 부분들이 닷넷 프레임워크를 사용하면 OS에 긴밀하게

290
00:26:46,429 --> 00:26:50,900
통합이 되어 있기 때문에
쉽게 이제 이를 구현할 수가 있었기 때문에 

291
00:26:50,900 --> 00:26:53,929
여전히 닷넷 프레임워크를 썼던 것이구요.

292
00:26:53,929 --> 00:26:58,659
반대로 안타깝게도 닷넷 코어, 닷넷 5의 경우에는

293
00:26:58,659 --> 00:27:05,133
이부분을 디커플링을 해버렸습니다. 그래서 윈도우 SDK랑 VS C++ 컴파일러가 있어야만

294
00:27:05,133 --> 00:27:10,220
이런 Out of Process 컴포넌트를

295
00:27:10,220 --> 00:27:13,850
만들고 등록을 할 때 타임 라이브러리 생성을 대행 해 줄 수 있고

296
00:27:13,850 --> 00:27:19,867
이런 작업들을 수 있는 그런 제약사항이 있었죠. 그래서 저는 컨셉 증명을 빨리 하고 싶었고 

297
00:27:19,867 --> 00:27:23,033
일을 빨르게 처리 하고 싶었기 때문에 

298
00:27:23,033 --> 00:27:28,490
닷넷 프레임워크 로 코드를 옮겨서 구현체를 만들게 되었던

299
00:27:28,490 --> 00:27:32,833
그런 배경이 있습니다.
그리고 앞서 말씀드렸다시피

300
00:27:32,833 --> 00:27:39,490
WSL 레지스터 디스트리뷰션이 정말
독특한 그런 동작을 가지고 있는데요.

301
00:27:39,490 --> 00:27:45,880
WSL API에서 이 함수를 찾아서 불렀더니, 전혀 엉뚱하게도

302
00:27:45,880 --> 00:27:52,067
exe 파일이, SDK가 실행되는 exe 파일에다가 WSL 배포판을 

303
00:27:52,067 --> 00:27:55,967
그것도 폴더 구분도 안하고 막 이렇게 만들더라구요. 
그래서 이게 어떻게 된 일이지? 하고 

304
00:27:55,967 --> 00:28:01,200
조금 더 찾아보다 보니, 쿼리 풀 프로세스 이미지 네임 이라고 하는

305
00:28:01,200 --> 00:28:04,600
이런 함수를 부르고 있는 걸 알 수 있었습니다.

306
00:28:04,600 --> 00:28:08,867
물론 제가 이 코드를, 모듈을 리버스엔지니어링 해본건 아니지만, 

307
00:28:08,867 --> 00:28:14,440
이런 함수가 이 함수가 하는 일은 이제
exe 파일의 경로를 찾아서

308
00:28:14,440 --> 00:28:19,590
반환하는 그런 함수인데, 굳이 이걸 여기서 부른다는 얘기는,

309
00:28:19,590 --> 00:28:24,280
쓸곳이 여기 뿐이구나. 그래서
이렇게 동작했구나. 라는 것을

310
00:28:24,280 --> 00:28:28,967
DLL 디펜더스 체커를 가지고서 바로 단박에 알아볼 수 있었구요.

311
00:28:28,967 --> 00:28:31,690
덕분에 아키텍처를 좀 더

312
00:28:31,690 --> 00:28:36,450
수정을 해야 되겠구나. 라는 결론을 낼 수 있었습니다.

313
00:28:37,720 --> 00:28:42,100
그래서 이렇게 개발을 진행을 해서 앞서 데모를 보여드렸던

314
00:28:42,100 --> 00:28:46,300
딱 그 수준으로 기능을 완성할 수 있었는데요.

315
00:28:46,300 --> 00:28:51,720
그런데 이제 정말 아쉽게도 WSL은 앞서 말씀드렸다시피

316
00:28:51,720 --> 00:28:57,033
모든 API를 잘 다듬어서 내놓은 형태가 아니고, 단순히

317
00:28:57,033 --> 00:29:03,467
LXSS 서비스 매니저 라고 하는, 숨겨진 그런 WSL 관리자, 관리 컴포넌트의 

318
00:29:03,467 --> 00:29:08,530
그런 기능들을 맵핑을 해서 내놓은 것에 불과하기 때문에, 사실은

319
00:29:08,530 --> 00:29:13,950
좀 더 많고, 복잡하고, 한편으로 고도화된 그런 기능을 사용을 할 때에는

320
00:29:13,950 --> 00:29:18,880
이 매니저 컴포넌트가 통신을 하는 게 좋다고 생각을 합니다.

321
00:29:18,880 --> 00:29:25,500
그런데 이 부분이 놀랍게도 
아직까지 마이크로소프트 Docs에 전혀 공개된 바가 없습니다.

322
00:29:25,500 --> 00:29:30,040
커뮤니티에서 매니저 컴포넌트의

323
00:29:30,040 --> 00:29:34,960
타임 라이브러리가 어떨 것이다, 라고 리버스엔지니어링해서 친절하게

324
00:29:34,960 --> 00:29:37,470
공개를 해 주신 분도 계시긴 한데요.

325
00:29:37,470 --> 00:29:43,690
사실은 이제 이 인터페이스가 정식으로 수시가 된 인터페이스가,

326
00:29:43,690 --> 00:29:47,950
사양이 공개가 된 인터페이스가 아니기 때문에 현재로서는 그냥

327
00:29:47,950 --> 00:29:51,310
재미삼아서 보는 정도로만 사용해야 될 것 같고

328
00:29:51,310 --> 00:29:56,260
실제 안정적으로 사용할 수 있는 그런 인터페이스가 아니라는

329
00:29:56,260 --> 00:30:01,180
점이 좀 많이 아쉬웠습니다.
그래서 이 부분은 향후에 어떻게 WSL이

330
00:30:01,180 --> 00:30:04,733
발전할 지는 모르겠지만, 점점 사용할 수 있는 

331
00:30:04,733 --> 00:30:10,650
API 서피스가 많이 늘어나지 않을까, 기대를 해봅니다.

332
00:30:15,930 --> 00:30:21,600
이제 제가 준비했던 내용은 거의 다 말씀을 드렸는데요. 

333
00:30:21,600 --> 00:30:29,210
몇 가지 결론에서, 전달 드리고 싶은 내용들을 정리해서 말씀을 드리려고 합니다.

334
00:30:29,890 --> 00:30:35,050
개발을 진행하고 나서 이제 뒤늦게 깨닫게 된 부분인데요.

335
00:30:35,050 --> 00:30:40,630
사실 이제 이렇게 힘들게 Out of Process COM서버를 만들었지만

336
00:30:40,630 --> 00:30:45,190
실제로 배포를 할 때 상당한 허들이 있다는 것을 깨닫게 됐습니다.

337
00:30:45,190 --> 00:30:49,000
리눅스도 그렇고 윈도우도 그렇고 요즘의 추세에 메타는 

338
00:30:49,000 --> 00:30:53,200
관리자 권한이 없다고 하더라도 일반 사용자 계정으로라도

339
00:30:53,200 --> 00:30:58,240
모든 일들은 할 수 있게, 혹은 권한 상승을 굳이 요구하지 않더라도

340
00:30:58,240 --> 00:31:02,033
사용자가 스스로 수행할 수 있는 작업은 그 안에서 자체적으로

341
00:31:02,033 --> 00:31:08,400
처리하도록 만드는 것이 전체적인
방향성과 흐름에, 트렌드에 맞는다, 라는 것을

342
00:31:08,400 --> 00:31:13,100
뒤늦게 깨닫게 되는데요.
Out of Process COM 서버에 경우에는

343
00:31:13,100 --> 00:31:18,280
다 좋은데 문제가, COM에 있는 아주 훌륭하고

344
00:31:18,280 --> 00:31:22,630
유용한 기능중에 하나인 비등록 사용 기능을 쓸 수가 없는

345
00:31:22,630 --> 00:31:26,650
그런 한계가 있었습니다.
그래서 이 부분을 해소를 하려면

346
00:31:26,650 --> 00:31:30,760
어떻게 해야 될까 고민을 하다가 결국은 답을 찾지 못했구요.

347
00:31:30,760 --> 00:31:35,500
그러던 와중에 생각을 바꾸게 됐습니다.

348
00:31:35,500 --> 00:31:39,867
ASP. NET Core가 기능이 계속 발전이 되면서

349
00:31:39,867 --> 00:31:44,367
모두들 아시다시피 gRPC 지원이 구글의

350
00:31:44,367 --> 00:31:51,200
Proto 8 해석기와 결합이 되면서 상당히 괜찮은 수준으로 
기능 개발이 되었죠.

351
00:31:51,200 --> 00:31:57,100
그 뿐만 아니라 윈도우에서 golang으로 뭔가 gRPC 관련 

352
00:31:57,100 --> 00:32:01,090
서버나 이런 툴 같은거를 오픈소스로도 만들어 놓은 것들을 보면

353
00:32:01,090 --> 00:32:06,933
대표적으로 containerd나, 쿠버네티스가 그렇게 구성이 되어 있는데요.

354
00:32:06,933 --> 00:32:15,360
그래서 네임드 파이프나 아니면 윈도우 10 1803 버전 이후로 
새로 추가가된 유닉스 소켓 개념이 이제

355
00:32:15,360 --> 00:32:21,233
연동이 됩니다. 그래서 ASP.NET Core에서 원래는

356
00:32:21,233 --> 00:32:26,380
TCP 포트로 랜덤 포트로 바인딩을 해서
이거 사용했어야 됐다 보니까

357
00:32:26,380 --> 00:32:30,880
아까 말씀드렸던 대로 포트 번호를
어떻게 알릴 것이냐에 대한 좀 미묘한

358
00:32:30,880 --> 00:32:34,390
문제가 있었습니다.
그런데 이 부분에 대해서

359
00:32:34,390 --> 00:32:39,310
마침 이제 윈도우 10 1803 에서 유닉스 소켓을 지원할 수

360
00:32:39,310 --> 00:32:44,380
있게 바뀐 덕분에 미리 약속된
파일 경로를 윈도우 환경변수

361
00:32:44,380 --> 00:32:49,933
시스템 환경변수 들을 적절하게 다 조립을 해서 이 부분을 맞출 수 있다면,

362
00:32:49,933 --> 00:32:53,470
Out of Process COM 서버를 썼을 때

363
00:32:53,470 --> 00:32:57,880
이점도 누리면서, 굳이 관리자 권한을 요구하지 않아도

364
00:32:57,880 --> 00:33:02,050
WSL SDK를 외부로 잘 빼낼 수 있겠구나.

365
00:33:02,050 --> 00:33:06,039
그런 생각을 할 수 있었습니다. 그 뿐만 아니라

366
00:33:06,039 --> 00:33:11,100
지금 윈도우 스토어로 이제 나중에
배포하는 부분을 감안해서도 그렇고

367
00:33:11,100 --> 00:33:16,000
또 이제 요즘, 이때 프로세스 뿐만이 아니라

368
00:33:16,000 --> 00:33:20,279
ARM 프로세서에 대한 지원들도 정말
여기저기서 많이 이루어지고 있는데

369
00:33:20,279 --> 00:33:24,760
WSL도 ARM 프로세서에 대한 것은 이미 지원을 잘 하고 있습니다

370
00:33:24,760 --> 00:33:30,190
그런데 이 부분까지 소화를 하기 위해서는,
이 경우 COM의 형태가 아니라

371
00:33:30,190 --> 00:33:35,049
이렇게 ASP.NET Core와 gRPC를 응용을 한. 이런 새로운

372
00:33:35,049 --> 00:33:39,100
형태의 모델을 이제 다시 적용을 해봐야 되겠다.

373
00:33:39,100 --> 00:33:42,190
그러면서도 유닉스 소켓이라던가, 아니면

374
00:33:42,190 --> 00:33:45,820
네임드 파이프 같은 개념들을 적극적으로 이용해서

375
00:33:45,820 --> 00:33:51,010
조금 더 접근하기 쉬운 형태로, 그리고
여러 언어로 사용이 쉬운 형태로 그렇게

376
00:33:51,010 --> 00:33:57,929
리비전 을 새로 만들어 나가려고 하는 그런 계획을 갖고 있습니다.

377
00:33:58,660 --> 00:34:05,050
그리고 Github Action이 현재 WSL 1을 사용해서 띄울 수 있도록

378
00:34:05,050 --> 00:34:10,929
되었습니다. 그래서 지금 참고로 WSL SDK도 Github에서

379
00:34:10,929 --> 00:34:16,929
빌드 파이프라인을 태울 때 WSL Extention, Github Action으로 

380
00:34:16,929 --> 00:34:21,460
누군가 개발해 주셔온 것이 있어가지고
요것을 잘 이용해서 빌드를 자동화를

381
00:34:21,460 --> 00:34:28,149
하는데 성공을 했습니다.
그래서 나중에는 WSL SDK도

382
00:34:28,149 --> 00:34:33,730
Github Action에서 사용할 수 있게끔 마찬가지로 패키징을 해서

383
00:34:33,730 --> 00:34:38,033
여러 개발자들의 생산성 향상에 크게 도움을 줄 수 있지 않을까

384
00:34:38,033 --> 00:34:41,550
그런 청사진도 가지고 있구요.

385
00:34:41,609 --> 00:34:46,080
그리고 제가 데모에서 보여드렸던 것은

386
00:34:46,080 --> 00:34:54,000
COM 서버를 사용할 수 있는 언어들에 한정해서 
다양한 언어들이 지원이 됩니다. 이런 취지로말씀드렸는데요.

387
00:34:54,000 --> 00:34:57,933
앞서 말씀드렸다시피 gRPC로 넘어갈 수 있다면

388
00:34:57,933 --> 00:35:03,030
그러면 조금 더 다양한 그런 언어들을 더 포괄적으로

389
00:35:03,030 --> 00:35:06,930
폭 넓게 지원할 수 있지 않을까 그런 생각을 해봅니다.

390
00:35:06,930 --> 00:35:11,730
그래서 API가 SDK 포함해서 모든 게 좀 어느정도

391
00:35:11,730 --> 00:35:17,010
안정화가 되었다고 생각이 들 때 본격적으로 여러 언어들을 위한

392
00:35:17,010 --> 00:35:22,640
SDK를 개발을 시작을 해서 커뮤니티에 선보일 수 있도록 이렇게

393
00:35:22,640 --> 00:35:26,270
구상을 하고 있습니다.

394
00:35:26,970 --> 00:35:33,267
그리고 도커와 도커 허브와 연계하는 그런 모델도 생각을 하고 있는데요.

395
00:35:33,267 --> 00:35:38,333
이제 도커 엔진이 제공하는 API를 직접 이용해서

396
00:35:38,333 --> 00:35:42,800
WSL 배포판을 만드는 과정에서 

397
00:35:42,800 --> 00:35:50,000
도커 파이를 스크립트를 사용해서 자동으로 WSL 배포판을 만들고 가져오고 내보내는 

398
00:35:50,000 --> 00:35:56,240
이런 동작을 역시 쉽게 개발할 수 있지 않겠는가. 그런 생각을 합니다.

399
00:35:57,360 --> 00:36:06,870
그래서 오늘 소개해 드렸던 내용들은
다시 요약을 해서 말씀해 드리면 크게 이렇습니다.
우선 마이크로소프트 Docs에서

400
00:36:06,870 --> 00:36:10,860
제공하고 있는 WSL에 관련된 API들은

401
00:36:10,860 --> 00:36:15,840
전적으로 WSL용 배포판을 새로 만들고자 하는 개발자들을 위하도록

402
00:36:15,840 --> 00:36:21,990
설계가 되었고 그런 방향으로 문서가 쓰여져 있었습니다. 그러다 보니

403
00:36:21,990 --> 00:36:27,780
다소 설명이 좀 불친절 하고 그리고 부족한 부분들이 좀 많았었습니다.

404
00:36:27,780 --> 00:36:33,000
그럼에도 불구하고 몇 가지 핵심적인 API들은 시나리오에 상관없이

405
00:36:33,000 --> 00:36:38,010
자유롭게 쓸 수 있도록 디자인 되어 있는 부분도 있어서 
그런 부분들을 이제 잘

406
00:36:38,010 --> 00:36:43,080
십분 활용하시면 좋을 것 같다는, 그런 말씀을 드리고요.

407
00:36:43,080 --> 00:36:48,500
그리고 rootfs를 활용하면 자유자재로

408
00:36:48,500 --> 00:36:56,089
WSL 배포판을 등록을 하고 삭제할 수 있다 라는 말씀을 드렸습니다. 
그리고

409
00:36:56,089 --> 00:37:01,010
WSL SDK는 지금 제가 개발하고 있는 이 프로젝트는

410
00:37:01,010 --> 00:37:06,650
현재 열심히 개발을 하고 있습니다.
그래서 그렇게 멀지 않은 시점에

411
00:37:06,650 --> 00:37:15,740
0.1 버전 이라고 말할 수 있는 수준까지 개발해서 
출시할 수 있지 않을까. 그런 생각을 해보고 있습니다.

412
00:37:15,740 --> 00:37:20,690
그리고 WSL 배포판은

413
00:37:20,690 --> 00:37:25,339
오늘 데모에서 보여 드렸다시피
내가 원하는대로 커스터마이징을 하고

414
00:37:25,339 --> 00:37:31,339
자유자재로 개발할 수가 있기 때문에
도커를 사용해도 좋고 아니면 기존의

415
00:37:31,339 --> 00:37:35,167
리눅스 커뮤니티에서 배포하고 있는
rootfs를 이용해도 좋습니다.

416
00:37:35,167 --> 00:37:41,660
어떤 방식이든 WSL을 끝까지 활용하면
이제 리눅스에 관련된 생산성을

417
00:37:41,660 --> 00:37:49,329
극대화하는데 매우 도움이 되지 않을까.
그런 전망을 볼 수 있었습니다.

418
00:37:50,050 --> 00:37:53,590
그래서 저희 커뮤니티 에 대해서 한번 더

419
00:37:53,590 --> 00:37:59,680
소개를 드리면 저희 커뮤니티는 
현재 페이스북 그룹으로 운영을 하고 있구요.

420
00:37:59,680 --> 00:38:04,333
그리고 Github에서도 오거나이제이션을 만들어서 
현재 활동하고 있습니다.

421
00:38:04,333 --> 00:38:14,050
그래서 저희 홈페이지를 하나 더 보여드리면

422
00:38:17,200 --> 00:38:22,990
wslhub.com에 오시면 지금 팀 멤버들이 같이 작성하고 있는

423
00:38:22,990 --> 00:38:28,890
미디엄 블로그에 여러 가지
트러블슈팅 가이드 같은 것들, 그리고

424
00:38:28,890 --> 00:38:34,690
제가 그동안 기고했었던 요런 미디엄 아티클들을 읽어 보실 수 있게

425
00:38:34,690 --> 00:38:37,240
미디엄 블로그 운영을 하고 있습니다.

426
00:38:37,240 --> 00:38:44,119
그리고 WSL 시작하기 라고 하는 그런 좋은 가이드도

427
00:38:44,119 --> 00:38:48,470
MkDocs 기반으로 만들어서 운영을 하고 있는데요.

428
00:38:48,470 --> 00:38:53,240
이렇게 처음에 WSL을 설치할 때 어떤 것들을 확인 해야 되고

429
00:38:53,240 --> 00:38:57,320
WSL 1과 2를 어떻게 설치해야 되는지 각각의 설치방법에 대해서

430
00:38:57,320 --> 00:39:02,700
그리고 흔히 하는 작업인 비주얼스튜디오 코드 연동 이나 ssh 키 생성

431
00:39:02,700 --> 00:39:06,410
이런 도커 설치하기 같이 다양한 그런

432
00:39:06,410 --> 00:39:11,359
주제들을 가지고서 개발환경 설정하기, 고급 가이드,

433
00:39:11,359 --> 00:39:15,470
트러블슈팅 까지 다양한 주제들을
다루고 있는 그런 문서 사이트도

434
00:39:15,470 --> 00:39:19,167
있으니깐요. WSL 에 대해서 좀 더 자세히 알고 싶거나

435
00:39:19,167 --> 00:39:22,967
배우고 싶으신 분들께 도움이 될 수 있도록

436
00:39:22,967 --> 00:39:28,690
자료를 만들었으니까 공유하고 활용해 주시면 좋을 것 같습니다.

437
00:39:31,340 --> 00:39:37,000
예 제 발표는 여기까지구요.
더 궁금하신점이나 알고 싶으신 부분이 있으면

438
00:39:37,000 --> 00:39:41,150
WSL Hub 커뮤니티(wsl.com)를 이용해
주시거나 혹은 메일 주소를 

439
00:39:41,150 --> 00:39:46,160
화면에 나와있는 메일 주소로 문의를 해주시면
제가 답변해 드릴수 있는

440
00:39:46,160 --> 00:39:50,570
한도에서 최대한 성심성의껏 답변해드리도록 하겠습니다.

441
00:39:50,570 --> 00:39:54,370
지금까지 발표 들어주셔서 감사합니다.

